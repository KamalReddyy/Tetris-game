# Deployment of Tetris game on Kubernetes and Automating it with argo-cd and terraform via jenkins Pipeline

# **Project Diagram**


 <img width="556" alt="diagram-of-tetris-game" src="https://github.com/user-attachments/assets/36be82ac-09f9-48db-b28f-d80cadbdd73e" />


# **Project Intoduction**

we are going to deploy 2 version of tetris game on aws EKS ckuster for this we are using terraform to create a base instance called the jenkins server than from this intance we setup pipeline for two version of tetris , which build docker image and push it to dockerhub than setup eks cluster and argo cd inside the cluster to deploy our application

# **Completion steps →**
Step 1 → Setup Terraform and configure aws on your local machine

Step 2 → Building a simple Infrastructure from code using terraform

Step 3 → Setup Sonarqube and jenkins

Step 4 → ci-cd pipeline to build and push the image to docker hub

Step 5→ Update Image name In deployment repo

Step 6→EKS cluster creation

Step 7→Install Argo cd

Step 8 →Deploy Application with ArgoCD

Step 9 →Destruction

# Step 1 → Setup Terraform and configure aws on your local machine

open your terminal and make a separate folder for Tetris→mkdir tetris-game
cd tetris-game
clone the github repo

```bash
git clone https://github.com/Aakibgithuber/Tetris-gamev1.git
```

# 1. Setup Terraform

To install terraform copy and paste the below commands:
```bash
sudo su
snap install terraform --classic
which terraform
```

<img width="519" alt="install-terraform" src="https://github.com/user-attachments/assets/ad31ec1e-0c07-413c-87a7-d0550e1ae67c" />

# 2. Configure aws

1. Create an IAM user
   click on iam

2. click on user →create user

3. Give a name to your user and tick on provide user access to management console and then click on I want an IAM user option

   <img width="669" alt="create-user" src="https://github.com/user-attachments/assets/6251be17-d80d-4d90-a990-d8844e870d60" />

4. choose a password for your user →click next

5. Attach the policies directly to your iam user → click next

note →I will provide the administrator accesss for now but we careful while attaching the policies at your workapce

<img width="679" alt="attach-policy-directly" src="https://github.com/user-attachments/assets/508c97ae-3dd9-4407-8a94-8647b34c50fe" />


review and create user

6. click on create user
   
<img width="829" alt="download-access-key" src="https://github.com/user-attachments/assets/501373c9-d6ab-47bb-8182-5428967b94cd" />

7. download your password file if it is autogenerated otherwise it is your’s choice

<img width="799" alt="done-create-user" src="https://github.com/user-attachments/assets/0b8b2eaf-133d-4495-bc50-af2ae13c639e" />

8. Now click on your IAM user →security credentials

9. scroll down to access keys and create an access keys

<img width="808" alt="keys" src="https://github.com/user-attachments/assets/d29d0f56-c3a2-4f66-8cf7-998bcd819f40" />

10.choose aws cli from the options listed 

11. click next and download you csv file for username and password

12.  go to your terminal and type →aws configure

13. Now it is ask to your access key and secret key for this open your csv file and paste the access and secret key and remain everything default

<img width="601" alt="install-aws" src="https://github.com/user-attachments/assets/d0d649da-6621-4ea7-ab70-8f6e5b13fa22" />

14. Now you are ready to configure aws from your terminal

# **Step 2 → Building a simple Infrastructure from code using terraform**

1.go to folder → cd Jenkins-terraform

2.there are four files present main.tf, install_jenkins.sh , provider.tf, backend.tf

3.open the file →vim Main.tf

4.main.tf includes userdata which links install_jenkins.sh file on which execution install jenkins,docker,trivy,and start the sonarqube container on port 9000


Note →you need to edit the key_name and ami section according to your aws account

5. exit from the file and edit backend.tf →vim backend.tf

Now run terraform commands →
```bash
terraform init
terraform validate
terraform plan
terraform apply --auto-approve

```

<img width="685" alt="terraform-init" src="https://github.com/user-attachments/assets/eb4ae2ff-8e08-4b9e-8092-e811777086bb" />

<img width="773" alt="terraform-plan" src="https://github.com/user-attachments/assets/899a5304-f51d-4607-a21f-c5302fb22342" />

<img width="779" alt="terraform-apply" src="https://github.com/user-attachments/assets/a10ec53c-a335-4895-bb9c-80f2c64f3d5a" />

Go to your aws console and checkout the ec2 instances

<img width="827" alt="launch-ec2" src="https://github.com/user-attachments/assets/7ab2023f-b3bc-4872-8781-26f2b4ac4600" />

<img width="797" alt="inbound-ec2" src="https://github.com/user-attachments/assets/2807366c-b924-4219-9e2f-15981b7a2122" />

Here we see Jenkins-Server instance is created by terraform with the given configuration

# Step 3 → Setup Sonarqube and jenkins

# 1.Sonarqube →
copy the public ip of your machine

1.go to your browser and type →<publicip>:9000

<img width="916" alt="sonarqube" src="https://github.com/user-attachments/assets/7a9e0e21-4132-4d9f-9e7a-b8d2c08b065d" />

sonarqube window open

2. iniatially username and password is admin

<img width="349" alt="update-pass-of-sonar" src="https://github.com/user-attachments/assets/517384ae-1fa8-4328-9720-a67402ad0175" />

3.update your password

4. welcome window of Sonarqube

# 2. Jenkins →
on browser type →<public_ip>:8080

<img width="785" alt="unloack-jenkins" src="https://github.com/user-attachments/assets/ddc11db1-0cf6-498f-b3a5-6bb48ab26d0a" />

2. for this go to your ec2 and connect it

3. run the below commands
   
```bash
sudo su
cat /var/lib/jenkins/secrets/initialAdminPassword
```

<img width="471" alt="initail-pass-of-jenkins" src="https://github.com/user-attachments/assets/ce723d62-6f8f-43d4-9fda-73a19f42788d" />

output is your password and paste it to your jenkins

4. Install the suggested plugins

<img width="673" alt="install-plugins" src="https://github.com/user-attachments/assets/59a07aeb-46ed-4181-9ea9-5c5af6542ca5" />

5. Setup your jenkins user

<img width="579" alt="jenkins-is-ready" src="https://github.com/user-attachments/assets/4fee915c-ada3-4f5a-99c9-003f87c38189" />

<img width="920" alt="welcome-to-jenkins" src="https://github.com/user-attachments/assets/a267a650-c4f9-4f4b-97b1-ee2c486a9730" />

Welcome to jenkins dashboard

#Step 4 → ci-cd pipeline to build and push the image to docker hub

1- Install Plugins listed below

1.Terrform

2.Eclipse Temurin Installer (Install without restart)

3.SonarQube Scanner (Install without restart)

4.NodeJs Plugin (Install Without restart)

5.Parameterized Trigger (to trigger another pipeline if one completed)

6.owasp →The OWASP Plugin in Jenkins is like a “security assistant” that helps you find and fix security issues in your software. It uses the knowledge and guidelines from the Open Web Application Security Project (OWASP) to scan your web applications and provide 
suggestions on how to make them more secure. It’s a tool to ensure that your web applications are protected against common security threats and vulnerabilities.

7.Prometheus metrics →to moniter jenkins on grafana dashboard

8.Download all the docker realated plugins

<img width="779" alt="add-nodejs-tools" src="https://github.com/user-attachments/assets/9561a57f-ed89-4be0-a87e-88c8515deb02" />

<img width="792" alt="add-owasp" src="https://github.com/user-attachments/assets/7cf9734d-8752-4251-b48e-3ca0857863d3" />

<img width="839" alt="add-sonarqube" src="https://github.com/user-attachments/assets/243bc856-c6c0-4986-9f3e-f7b6271fb82d" />

<img width="885" alt="add-terraform" src="https://github.com/user-attachments/assets/459ddb75-0076-48f4-b1c4-0994730a06ab" />

1. add credentials of Sonarqube and Docker

1st we genrate a token for sonarqube to use in jenkins credentials as secret text

a. setup sonarqube credentials

1.go to http://publicip:9000

2.now enter your username and password

3.click on security →users →token →generate token

4.token_name==sonar-token

<img width="866" alt="sonar-tokenn" src="https://github.com/user-attachments/assets/fb6ac31a-0b4c-4d01-ad8d-aafcfd3f52ef" />

5. copy the token and go to your jenkins →manage jenkins →credentials →global →add credentials

6. select secret text from dropdown

7. secret text ==your token , id =sonar-token →click on create

<img width="871" alt="cred-jenk-token,sonar" src="https://github.com/user-attachments/assets/c617c993-5dbc-4e60-bc0e-4c887b614c53" />

b. setup projects in sonarqube for jenkins

1.go to your sonarqube server

2.click on projects

3.in the name field type tetris

4.click on set up

<img width="356" alt="project-manually-tetrisv1" src="https://github.com/user-attachments/assets/ff52177e-82e1-44a1-93ec-312172e76f7a" />
click on manually

<img width="737" alt="run-analysis-on-your-project" src="https://github.com/user-attachments/assets/7fc7c037-5975-4353-8d91-d620e3eb90c6" />

<img width="532" alt="analyze-token-provide" src="https://github.com/user-attachments/assets/ec2dbb3b-161d-4066-8cd0-85e6f56136bb" />

Sonarqube project for jenkins is setup now

C. Now setup Webhooks for sonarqube
webhook in SonarQube is a way for SonarQube to notify or inform other systems or tools when something important happens. It’s like a virtual hand raising to say, “Hey, something noteworthy just occurred here!”

1.Go to adiministration →configuration →webhooks

<img width="250" alt="create-webhooks" src="https://github.com/user-attachments/assets/31f546d8-80b6-4fc0-8e6f-32c41387e9b5" />

2. click on create and your webhook is created

Sonarqube is setup here

d. Setup docker credentials
1.go to your jenkins →manage jenkins →credentials →global →add credentials

2.provide your username and password of your dockerhub

3.id==docker

<img width="892" alt="docker-cred" src="https://github.com/user-attachments/assets/73027be8-7701-4b87-bb20-147f3944989f" />

e. setup git credentials →click on me to see how to generate token in github

1.Now copy that token from github and

2.go to your jenkins →manage jenkins →credentials →global →add credentials

3.provide your username and password of your github

4.id==github

2. Now we are going to setup tools for jenkins
go to manage jenkins → tools

a. add jdk

1.click on add jdk and select installer adoptium.net

2.choose jdk 17.0.8.1+1version and in name section enter jdk 17

<img width="802" alt="install-jdk" src="https://github.com/user-attachments/assets/777b4b62-bfea-422e-8198-fc30820ea146" />

b. add node js

1.click on add nodejs

2.enter node16 in name section

3.choose version nodejs 16.2.0

<img width="779" alt="add-nodejs-tools" src="https://github.com/user-attachments/assets/39e53967-ef3f-4d37-bc38-33bf151c8a3d" />

c. add docker →

1.click on add docker

2.name==docker

3.add installer ==download from docker.com

<img width="824" alt="install-docker-tools" src="https://github.com/user-attachments/assets/92f733a9-fe8d-487b-9ad4-7c4fe4f7c1e9" />

d. add sonarqube →

1.add sonar scanner

2.name ==sonar-scanner

<img width="839" alt="add-sonarqube" src="https://github.com/user-attachments/assets/6d137f15-e9d6-47e1-a0ba-bee0d35fb1fa" />

e. add owasp dependency check →
Adding the Dependency-Check plugin in the “Tools” section of Jenkins allows you to perform automated security checks on the dependencies used by your application

1.add dependency check

2.name == DP-Check

3.from add installer select install from github.com

<img width="792" alt="add-owasp" src="https://github.com/user-attachments/assets/e9bcb329-a470-4971-8401-1dd22d595b3d" />

f. terraform

1.go to manage jenkins →tools →search for terraform

2.add terraform

3.provide the name in the name field and untick the install automatically option and give the path /usr/bin/

4.As terraform is installed in this section it takes it from there

<img width="885" alt="add-terraform" src="https://github.com/user-attachments/assets/e060ddd9-65c5-44b8-92a3-7bc598745413" />

5. click on apply and save

3. Configure global setting for sonarube

1.go to manage jenkins →Configure global setting →add sonarqube servers

2.name ==sonar-server

3.server_url==http://public_ip:9000

4.server authentication token == sonar-token→it is created in sonarqube security configurations

All the tools and configurations for jenkins are set up now let’s run the pipeline

# 4. pipeline script for building image and push it to dockerhub(Version1)

1.click on new item and name it tetris image build and click on ok

2. scroll to pipeline script and paste the following script there

```bash

pipeline{
    agent any
    tools{
        jdk 'jdk17'
        nodejs 'node16'
    }
    environment {
        SCANNER_HOME=tool 'sonar-scanner'
    }
    stages {
        stage('clean workspace'){
            steps{
                cleanWs()
            }
        }
        stage('Checkout from Git'){
            steps{
                git branch: 'main', url: 'https://github.com/Aakibgithuber/Tetris-gamev1.git'
            }
        }
        stage("Sonarqube Analysis "){
            steps{
                withSonarQubeEnv('sonar-server') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=TetrisVersion1.0 \
                    -Dsonar.projectKey=TetrisVersion1.0 '''
                }
            }
        }
        stage("quality gate"){
           steps {
                script {
                    waitForQualityGate abortPipeline: false, credentialsId: 'sonar-token' 
                }
            } 
        }
        stage('Install Dependencies') {
            steps {
                sh "npm install"
            }
        }
        stage('OWASP FS SCAN') {
            steps {
                dependencyCheck additionalArguments: '--scan ./ --disableYarnAudit --disableNodeAudit', odcInstallation: 'DP-Check'
                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
            }
        }
        stage('TRIVY FS SCAN') {
            steps {
                sh "trivy fs . > trivyfs.txt"
            }
        }
        stage("Docker Build & Push"){
            steps{
                script{
                   withDockerRegistry(credentialsId: 'docker', toolName: 'docker'){   
                       sh "docker build -t tetrisv1 ."
                       sh "docker tag tetrisv1 marwanhesham463/tetrisv1:latest "
                       sh "docker push marwanhesham463/tetrisv1:latest "
                    }
                }
            }
        }
        stage("TRIVY"){
            steps{
                sh "trivy image marwanhesham463/tetrisv1:latest > trivyimage.txt" 
            }
        }
    }

```

<img width="936" alt="pipeline-v1-success" src="https://github.com/user-attachments/assets/6a898eb7-b029-4a28-8b9c-f7354847eefe" />

<img width="930" alt="pipeline-steps-v1" src="https://github.com/user-attachments/assets/bc97d271-58f7-4c56-be8a-03ff110ebb93" />

<img width="932" alt="pipeline-v1-done" src="https://github.com/user-attachments/assets/292f0a8e-ccb5-434f-9c03-b5b109680a4b" />

# **Your image is build and push to dockerhub let’s see changes in dockerhub**

<img width="688" alt="dockerhub-v1" src="https://github.com/user-attachments/assets/9e2c40fc-cc81-4c2c-8d48-2263794f7207" />

5. pipeline script for building image and push it to dockerhub(Version2)
for version 2 you only need to change the url of your repo

2. pipeline script for version 2
```bash
pipeline{
    agent any
    tools{
        jdk 'jdk17'
        nodejs 'node16'
    }
    environment {
        SCANNER_HOME=tool 'sonar-scanner'
        GIT_REPO_NAME = "Tetris-deployment-file"
        GIT_USER_NAME = "Aakibgithuber"      
    }
    stages {
        stage('clean workspace'){
            steps{
                cleanWs()
            }
        }
        stage('Checkout from Git'){
            steps{
                git branch: 'main', url: 'https://github.com/Aakibgithuber/tetris-gamev2.git'
            }
        }
        stage("Sonarqube Analysis "){
            steps{
                withSonarQubeEnv('sonar-server') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=tetrisv1 \
                    -Dsonar.projectKey=tetrisv1 '''
                }
            }
        }
        stage("quality gate"){
           steps {
                script {
                    waitForQualityGate abortPipeline: false, credentialsId: 'Sonar-token' 
                }
            } 
        }
        stage('Install Dependencies') {
            steps {
                sh "npm install"
            }
        }
        stage('OWASP FS SCAN') {
            steps {
                dependencyCheck additionalArguments: '--scan ./ --disableYarnAudit --disableNodeAudit', odcInstallation: 'DP-Check'
                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
            }
        }
        stage('TRIVY FS SCAN') {
            steps {
                sh "trivy fs . > trivyfs.txt"
            }
        }
        stage("Docker Build & Push"){
            steps{
                script{
                   withDockerRegistry(credentialsId: 'docker', toolName: 'docker'){   
                       sh "docker build -t tetrisv2 ."
                       sh "docker tag tetrisv2 aakibkhan1212/tetrisv2:latest "
                       sh "docker push aakibkhan1212/tetrisv2:latest "
                    }
                }
            }
        }
        stage("TRIVY"){
            steps{
                sh "trivy image aakibkhan1212/tetrisv2:latest > trivyimage.txt" 
            }
        }
        stage('Checkout Code') {
            steps {
                git branch: 'main', url: 'https://github.com/Aakibgithuber/Tetris-deployment-file.git'
            }
        }
        stage('Update Deployment File') {
            steps {
                script {
                    withCredentials([string(credentialsId: 'github', variable: 'GITHUB_TOKEN')]) {
                       NEW_IMAGE_NAME = "aakibkhan1212/tetrisv1:latest"  
                       sh "sed -i 's|image: .*|image: $NEW_IMAGE_NAME|' deployment.yml"
                       sh 'git add deployment.yml'
                       sh "git commit -m 'Update deployment image to $NEW_IMAGE_NAME'"
                       sh "git push @github.com/${GIT_USER_NAME}/${GIT_REPO_NAME">https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME} HEAD:main"
                    }
                }
            }
        }
    }
}
```

<img width="878" alt="pipeline-v2" src="https://github.com/user-attachments/assets/3429758a-dc46-4b04-bc85-1ff9632043c8" />

<img width="680" alt="dockerhub-2v" src="https://github.com/user-attachments/assets/566e26e5-8b24-4f9a-a660-98b5cb112a3e" />

# Step 5→ Update Image name In deployment repo

Everything is done now we need to update the image name in my second repository that is used for creating pod inside our Elastic kubernetes cluster

1.go to →https://github.com/Marwan933/Tetris-game/blob/main/deployment.yml

2. you need to automate that when image is build and push by above pipeline than it is automatically update the image name here with the image name created by above pipeline

3. So for that we need to create another pipeline and use the triggerd option means when one pipeline succesfully complete which push the image to dockerhub than it triggers to another pipeline which is than update the image name in the tetris deployment repository

```bash
#add inside environment
 environment {
    GIT_REPO_NAME = "Tetris-deployment-file"
    GIT_USER_NAME = "Aakibgithuber"      # change your  Github Username here
  }

# add these stages after trivy image scan 
        stage('Checkout Code') {
            steps {
                git branch: 'main', url: 'https://github.com/Aakibgithuber/Tetris-deployment-file.git'
            }
        }
        stage('Update Deployment File') {
            steps {
                script {
                    withCredentials([gitUsernamePassword(credentialsId: 'github', gitToolName: 'Default')]){
                       NEW_IMAGE_NAME = "aakibkhan1212/tetrisv1:latest"   #update your image here
                       sh "sed -i 's|image: .*|image: $NEW_IMAGE_NAME|' deployment.yml"
                       sh 'git add deployment.yml'
                       sh "git commit -m 'Update deployment image to $NEW_IMAGE_NAME'"
                       sh "git push @github.com/${GIT_USER_NAME}/${GIT_REPO_NAME">https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME} HEAD:main"
                    }
                }
            }
        }
```
4. click on build

# Step 6→EKS cluster creation

Create cluster without terraform
Note!! use this step if you don’t want to use jenkins pipeline for eks cluster creation

1.In your base ec2 run the below command

```bash
eksctl create cluster --name EKS-CLOUD --region us-east-1 --node-type t2.medium --nodes-min 1 --nodes-max 2
aws eks update-kubeconfig --region us-east-1 --name EKS-CLOUD

```

<img width="928" alt="create-cluster-on-ec2-2" src="https://github.com/user-attachments/assets/3ba089bd-3616-4b01-a5ea-4968b6c293e6" />

<img width="878" alt="cluster-update-kubeconfig" src="https://github.com/user-attachments/assets/b948ccb2-4a07-45fa-ba5a-574a0a3dc0d1" />

# Step 7→Install Argo cd
Argo CD is a tool that helps software developers and teams manage and deploy their applications to Kubernetes clusters more easily. It simplifies the process of keeping your applications up to date and in sync with your desired configuration by automatically syncing your code with what’s running in your Kubernetes environment. It’s like a traffic cop for your chmod 700 get_helm.shapplications on Kubernetes, ensuring they are always in the right state without you having to manually make changes.

First we need to install helm →Install helm

```bash
snap install helm --classic
```

<img width="584" alt="install-helm-and-ardocd" src="https://github.com/user-attachments/assets/5fcaf302-1f43-4a88-a901-d1ee2b50bdff" />

1.Add the Argo CD Helm repository:

```bash
helm repo add argo-cd https://argoproj.github.io/argo-helm
```

2. Update your Helm repositories:
```bash
helm repo update
```
3. Create a namespace for Argo CD (optional but recommended):
```bash
kubectl create namespace argocd
```

4. Install Argo CD using Helm:
```bash
helm install argocd argo-cd/argo-cd -n argocd
```
5. To see installation of argocd run
```bash
kubectl get all -n argocd
```

<img width="767" alt="kubectl-get-all" src="https://github.com/user-attachments/assets/a55302ae-dfc6-45b2-af55-7da94294aa80" />


# Expose argocd-server

By default argocd-server is not publicaly exposed. For the purpose of this workshop, we will use a Load Balancer to make it usable:

```bash
kubectl patch svc argocd-server -n argocd -p ‘{“spec”: {“type”: “LoadBalancer”}}’
snap install jq
export ARGOCD_SERVER=`kubectl get svc argocd-server -n argocd -o json | jq --raw-output '.status.loadBalancer.ingress[0].hostname'`
echo $ARGOCD_SERVER
```
<img width="436" alt="echo-argodc" src="https://github.com/user-attachments/assets/d1c07b12-ad7f-4146-89b5-032bac3bbfe8" />

**you have given a url copy and paste it on your chrome browser**

<img width="908" alt="welcome-to-argocd" src="https://github.com/user-attachments/assets/df948328-be61-4c95-8986-8bc83ddfac4c" />

username ==admin
For Password →

```bash
export ARGO_PWD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
echo $ARGO_PWD
```
1.output == password for argocd

<img width="925" alt="get-pass-of-argocd" src="https://github.com/user-attachments/assets/df0aef32-91b1-4f29-bc3e-9ecde1c0443b" />

copy and paste the password on argocd page and you are logged in

# Step 8 →Deploy Application with ArgoCD

Sign into argo cd using above steps →

1.go to setting →repositories →connect repo

<img width="910" alt="information-on-connect-repo-argocd" src="https://github.com/user-attachments/assets/9ac3d44d-6f29-474d-98cd-c462bcee5f51" />

select these options and on repo url copy n paste below github url https://github.com/Aakibgithuber/Tetris-deployment-file.git

2. click on connect output →successful

3. Now go to application →newapp

<img width="957" alt="newapp-argocd" src="https://github.com/user-attachments/assets/0dabd73f-ce4d-48d6-b461-2f072badea5f" />

4. select the above options and click on create

5. Now click on sync →force →sync →ok

<img width="897" alt="data-of-sync" src="https://github.com/user-attachments/assets/d1473fa0-1d25-46d9-bea6-00c8349be4e5" />

6. click on tetris-service →details
   
 <img width="939" alt="tetris-in-argocd" src="https://github.com/user-attachments/assets/2bc43719-3d11-4ef8-91e7-8f3b82de570c" />

 <img width="929" alt="hostname-of-argo" src="https://github.com/user-attachments/assets/c117456b-c766-4847-bca5-98b8b392f1c1" />

7.copy the load balancer ingress url and paste it to web browser

<img width="883" alt="finally-tetris-game-done" src="https://github.com/user-attachments/assets/3c513154-50fe-4710-abb9-bac7b30973c9" />

# run the below command and open the listed port
```bash
kubectl get all
```
<img width="767" alt="kubectl-get-all" src="https://github.com/user-attachments/assets/2f595ab5-f2b6-4bcb-b9f8-bbc0fd045666" />

8. This is the version 1 of application for version 2

1.go to your github and locate the deployment repo and change the image name in deployment.yaml file

2. change the image name from v1 to v2

3. go to your argo cd and click on sync →force →sync →ok

<img width="932" alt="finally-argocd-2" src="https://github.com/user-attachments/assets/cfb58654-82d2-481b-a6ff-30462e627f98" />

4. now again refresh the load balancer ingress

<img width="937" alt="finally-tetris-v2" src="https://github.com/user-attachments/assets/486b576b-c7fd-404e-9f1f-2db1f492cf8c" />

click on start

<img width="930" alt="finally-tetris-v2 2" src="https://github.com/user-attachments/assets/16ef76b4-1f96-40c7-bc59-eff83b134d7e" />

Here is our new version of game
our both version of game is deployed now let’s destroy all the resources

# Step 9 →Destruction
 1.Deletion of app in argo cd
 2. Delete argo cd from terminal of jenkins server node
```bash
kubectl delete svc argocd-server -n argocd
```
<img width="606" alt="delete-svc-cluster" src="https://github.com/user-attachments/assets/88523c10-1814-4f91-bb89-6640e40bf825" />

3. Now delete the EKS cluster (two ways )

1.delete using jenkins pipeline by terraform

2. delete from terminal if you have used aws cli to create → Cluster run the following command on jenkins server node
   
```bash
eksctl delete cluster --name EKS_CLOUD--region us-east-1
aws cloudformation delete-stack --stack-name eksctl-EKS_CLOUD
```

4. delete the base EC2 or jenkins server → go to your terminal and run the
   
```bash
terraform destroy --auto-approve
```

# finally, Done...
